---
layout: post
title: Introduccion a R
published: true
comments: true
---

<a name="top"></a>

- [Introducción y objetivos](#intro)
- [Instalación R, Rstudio, paquetes](#install)
- [Data managment, parte I](#data1)
- [¿Cómo leer  archivos en  R?](#leer)
- [Funciones](#funciones)
- [Estructuras de control](#estructuras)

----------

### <a name="intro"></a>Introducción y objetivos

Introducción al uso de R como lenguaje de programación estadístico
-------------

El presente módulo introduce al participante en el manejo del software R, lo cual comprende la instalación y configuración del software necesario para el entorno de programación estadístico, la discusión de los conceptos del lenguaje de programación genéricos. Además, temas teórico-prácticos de la estadística, programación básica con el uso del script, manipulación de bases de datos, funciones y herramientas gráficas.

El objetivo del curso es actualizar-ampliar los conocimientos en la optimización de la gestión de información cuantitativa empoderando  al participante de destrezas en el manejo del soft- ware R en data  management, estadística  descriptiva,  gráficos, modelos lineales, clasificación, series de tiempo, con base a aplicaciones y casos prácticos.

 - Introducir al participante en el uso del software R como lenguaje de programación.
 - Mejorar las habilidades  de gestión de información del participante.
 - Incrementar el conocimiento de modelos y su aplicación.

Visión general de R: instalación RStudio y otros
-------------
Introducción
-------------
R es un sistema para análisis estadístico y gráficos creado por Robert Gentleman y Ross Ihaka, profesores del departamento de Estadística de University of Auckland - New Zealand.

Ventajas
-------------
 - Open Source (Costo nulo) Comunidad  dinámica integrada por estadísticos de renombre(R  User Group Ecuador, Stackoverflow, Comunidad  R Hispano, R en español,. . . ) 
 - Multi-plataforma: Disponible para Windows, Mac, Linux y Android. 
 - Es de código abierto.
 - Facilidad de enlace con LateX y generar reportes dinámicos.  
 - Amplia bibliografía en la web y libros publicados por editoriales prestigiosas (Springer, Wiley, Chapman  & Hall,. . . ) 
 - Lenguaje intuitivo para la lectura de funciones y algoritmos.

Desventajas
-------------
 - Por ser un programa libre, no posee garantía  ni un departamento de atención al cliente.
 - R no posee una interfaz  amigable, las tareas  se llevan a través  de líneas de código, lo cual puede ser incómodo para el usuario.
 - R particularmente no es un lenguaje de programación  rápida.

Cómo funciona R
-------------

<center>
![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-funciona_r.jpg)</center>
<br>

[Back to Top](#top)

### <a name="install"></a>Instalación de R, RStudio y paquetes

Instalación  de  R
-------------
 1. Ingresar a https://www.r-project.org/ 
 2. Elegir el CRAN (Comprehensive R Archive Network) 
 3. Escoger versión del sistema operativo.  
 4. Instalar R por primera  vez.

<center>![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-install_r.gif)</center>
<br>

R como una calculadora
-------------
```{r}
3*8
```


```{r}
2.8/6.8
```


```{r}
sqrt(25)
```

Además, cada operación anterior  puede ser almacenada  en un “objeto"

```{r}
a<-3*8
b<-2.8/6.8
D<-sqrt(25)
```


Instalación de RStudio
-------------

 1. Ingresar a https://www.rstudio.com/ 
 2. Productos 
 3. Escoger versión según el Sistema Operativo

<center>![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-rstudio_install.gif)</center>
<br>

----------

Instalación  de  paquetes
----------

Además de las funciones básicas, R tiene un gran número de paquetes especializados.

Los paquetes se instalan una sola vez y deben ser cargados en cada inicio de sesión.

Se utiliza la siguiente función:


    install.packages("dplyr",dependencies = TRUE)

Una vez instalado,  debemos cargarlo con cualquiera de estos comandos:


    require(dplyr)
    library("dplyr")

Para instalar un paquete desde otro repositorio:


    install.packages("survey", repos="http://r-forge.r-project.org", type="source")
    library(survey)

Desde github y con otra forma de cargar una función de una librería:


    install.packages("githubinstall")
    githubinstall::githubinstall("twitter/AnomalyDetection")


Otra forma de cargar desde github:


    source("https://install-github.me/r-lib/callr")
    library("callr")

Para poder ver los paquetes instalados y disponibles podemos utilizar:


    library()
    installed.packages()
    .packages(all.available=TRUE)
    available.packages() 


Para saber cuál fue el último paquete instalado utilizamos:


    (.packages())


Es importante saber que funciones tiene cada paquete, para esto utilizamos:


    ls("package:dplyr")

[Back to Top](#top)


### <a name="data1"></a>Data management, parte I


Estructuras de  Datos
----------

Las estructuras de datos en R se organizan por: Dimensionalidad y Homogeneidad o heterogeneidad.

R no tiene estructuras 0d (tipo escalar). Los números y strings individuales son considerados como vectores de longitud 1.

```{r}
# no mostrar advertencias
options(warn = -1) 
x <- 9
x
```

El texto luego de # es un comentario (no es interpretado por R). Para crear un objeto se utiliza el operador de asignación  <-, =, ->.
```{r}
y="SSh"
y
```

Vectores
----------
La estructura de datos básica de R son los vectores, estos se dividen en Vectores atómicos y listas.

Propiedades:
----------

Tipo: ¿Qué es?

```{r}
typeof(x)
```


Longitud: Número de elementos.
```{r}
length(x)
```


Atributos: Características.
```{r}
attributes(x)
```

Vectores Atómicos
----------
Los elementos de un vector atómico son del mismo tipo a diferencia de los elementos de una lista que pueden ser de diferente tipo. Los tipos comunes son:

 - double (numeric)
 - integer
 - character
 - logical

 

Función  combinar
----------

Un vector es creado mediante  la función  c( )  (combinar).
```{r}
vec <- c(1, 2)
vec
```

Tipos de  Vectores Atómicos:
----------
Vector double;

```{r}
dbl_vec <- c(3.5, 2, -1)
```

Vector entero: Use el sufijo L para crear un vector entero;

```{r}
int_vec <- c(3L, 7L, 1L)
```


Vector caracter: Use “  ”  para crear un vector caracter;

```{r}
chr_vec <- c("Science", "&", "Apps")

```


Vector lógico: Use TRUE y FALSE o T y F para crear un vector lógico.

```{r}
log_vec <- c(FALSE, TRUE, F, T)

```


Para  determinar si un vector vec es atómico utilizamos is.atomic(vec).

```{r}
vec <- c(3.5, 2, -1)
is.atomic(vec)

```


Para  determinar el tipo de un vector vec utilizamos typeof(vec).

```{r}
vec <- c("Science", "&", "Apps")
typeof(vec)

```

Para  verificar si un vector vec es de un tipo en específico, se utilizan  las funciones “is”: 


```{r}
is.character(vec)
is.double(vec)
is.integer(vec)
is.logical(vec)

```


Elementos de  un  vector atómico: La componente i de vec se obtiene mediante  vec[i].

Componente 5 de vec:
```{r}
vec <- c(6, 1, 3, 6, 10, 5)
vec[5]
```

Para  seleccionar varios elementos utilizamos vec[c(elementos)].


```{r}
# elementos 2 y 4 
vec[c(2, 4)]

```

Para  omitir el elemento i de vec se utiliza vec[-i].
```{r}
vec <- c(6, 1, 3, 6, 10, 5)
vec[-5]

```


Para  omitir varios elementos utilizamos vec[-c(elementos)].
```{r}
# omitir los elementos 2 y 4
vec[-c(2, 4)]

```

Generación de secuencias: El operador a:b genera el vector a, a+1, a+2, ..., b. 

```{r}
1:10
5:-5
```


La función seq( ) genera secuencias controlando: inicio, fin y salto.
```{r}
seq(from = 1, to = 10, by = 0.5)
seq(from = -4, to = 4, length = 5)
```


vec[c(TRUE, FALSE)] permite obtener determinados elementos:

```{r}
# elementos 2, 4, 6
vec <- c(6, 1, 3, 6, 10, 5)
vec[c(FALSE, TRUE, FALSE, TRUE, FALSE, TRUE)]

```


Equivalente a:
```{r}
vec[c(2, 4, 6)]
```


Operaciones con  vectores
----------

A continuación, se resumen las operaciones básicas con vectores atómicos:

<center>![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-operaciones.jpg)</center>
<br>

Función all(x) retorna TRUE si todas las componentes de x son TRUE.

```{r}
x <- c(TRUE, TRUE, TRUE)
all(x)
```

```{r}
y <- c(TRUE, FALSE, TRUE)
all(y)
```

Función any(x)  retorna TRUE  si al menos una componente de x es TRUE.
```{r}
x <- c(FALSE, FALSE, FALSE)
any(x)
```

```{r}
y <- c(FALSE, TRUE, FALSE)
any(y)

```

Negación !x cambia las componentes de x de: TRUE  a FALSE y de FALSE a TRUE:

```{r}
x <- c(TRUE, FALSE, TRUE)
!x

```

Conjunción x & y retorna TRUE solo si las componentes de x & y son TRUE:

```{r}
x <- c(TRUE, TRUE, FALSE) 
y <- c(FALSE, TRUE, TRUE)
x & y

```
```{r}
x && y # conjuncion para escalares
```

Disyunción x | y retorna TRUE  si al menos una componente de x o y es TRUE

```{r}
x <- c(TRUE, TRUE, FALSE) 
y <- c(FALSE, TRUE, TRUE) 
x | y

```

```{r}
x || y # disyuncion para escalares
```


Dado un vector lógico x:

```{r}
x <- c(TRUE, TRUE, FALSE, TRUE, FALSE)
```

sum(x).  Cuenta el número de TRUE  en x.
```{r}
sum(x)
```

mean(x).  Muestra el porcentaje de TRUE  en x.

```{r}
mean(x)
```

```{r}
sum(x)/length(x)
```

Test de igualdad y desigualdad
```{r}
x <- c(3, 5, 2, 3, 1) 
x==3
```

```{r}
y <- x==3 # componentes iguales a 3
z <- x!=3 # componentes distintas a 3 
data.frame(x, y, z)
```

```{r}
x[x!=3] # componentes de x distintas a 3
```

Coerción: Si combinamos tipos diferentes, serán coercionados al tipo más ﬂexible dado por la jerarquía:

<center>![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-coersion.jpg)</center>
<br>

Para coercionar un vector x a un determinado  tipo, se utilizan  las funciones “as”

```{r}
as.character(x)
as.double(x)
as.integer(x)
as.logical(x)
as.numeric(x) 
```


Listas
----------

Una lista es un vector que puede contener elementos de cualquier tipo y de distinta longitud.

Para crear una lista se utiliza la función list() en lugar de c().
```{r}
lst <- list(c(1, 2), c(TRUE), c("a", "b", "c"))
lst

```

Tests para una lista:	
```{r}
lst <- list(1:3, c("Source", "Stat", "Lab"), c(TRUE, FALSE), c(1.3, 4.5))
typeof(lst)

```
```{r}
is.atomic(lst)
```

Para  probar  si lst es una lista se utiliza:	
```{r}
is.list(lst)	
```

Coerción de vector atómico lst a una lista

```{r}
lst <- c("ssl", 4, 0.5)
as.list(lst)

```


Coerción de lista lst a vector atómico (reglas de coerción)

```{r}
lst <- list(1:3, c("Science", "&", "Apps"), c(TRUE, FALSE), c(1.3, 4.5))
unlist(lst)

```

Elementos de una lista: Para acceder al elemento i de la lista se utiliza x[i]. Para  acceder al objeto que contiene el elemento i se utiliza x[[i]].

 
```{r}
lst <- list(c(1, 2), c(TRUE), c("a", "b", "c"))
lst[1]
```

```{r}
lst[[1]]
```

En una lista con nombre podemos utilizar el simbolo $ para extraer determinados elementos:

```{r}
lst <- list(v=1:3, w=c("Source", "Stat", "Lab"), x=c(TRUE, FALSE), y=c(1.3, 4.5))
lst$w

```

Utilizar lst$w resulta  equivalente  a utilizar  lst[[2]] 

```{r}
lst[[2]]
```


Atributos
----------

Los objetos en R poseen varios atributos tales  como: names,  class, dim,  etc.  La función attributes(x) muestra los atributos de un objeto x.

Vector atómico:

```{r}
# Vector sin el atributo names 
vec <- c(3, 6, -1, 0.5) 
attributes(vec)
```

```{r}
# Vector con el atributo names 
vec <- c(a=3, b=6, c=-1, d=0.5) 
attributes(vec)
```

Lista:
```{r}
# Lista sin el atributo names
lst <- list(1:3, c("Science", "&", "Apps"), c(TRUE, FALSE))
attributes(lst)
```

```{r}
# Lista con el atributo names
lst <- list(nomb1=1:3, nomb2=c("Source", "Stat", "Lab"), nomb3=c(TRUE,FALSE))
attributes(lst)
```

Matrices
----------
Una  matriz  es un vector  con el atributo dimensión  dim. El atributo dim es un vector  de longitud 2: c(nrow, ncol). 

```{r}
mtx <- matrix (1:12,nrow=3, ncol=4, byrow=FALSE)
# se construye por columnas por default (byrow=FALSE)
mtx
```


dim()  se usa para  añadir  el atributo dimensión a un vector,  o para  hallar la dimensión de una matriz.

```{r}
mtx <- 1:12
mtx	
```

```{r}
dim(mtx) <- c(3,4)
mtx	
```

```{r}
mtx <- matrix (1:12, nrow=3, ncol=4, byrow=FALSE)
dim(mtx)
```


Elementos de una matriz:

```{r}
(mtx <- matrix (1:12, nrow=3, ncol=4, byrow=FALSE))
```


```{r}
mtx[1,2] # componente 1, 2
```


```{r}
mtx[,3] # columna 3
```

```{r}
mtx[1,] # fila 1
```


```{r}
mtx[,c(2,4)] # columnas 2 y 4
```

```{r}
mtx[c(1,3),] # filas 1 y 3
```

```{r}
mtx[,c(FALSE, TRUE, TRUE, FALSE)] # columnas 2 y 4
```

```{r}
mtx[c(TRUE, FALSE, TRUE),] # filas 1 y 3
```

Factores
----------
Es la estructura  de datos utilizada para almacenar  variables  categóricas. ¿Por qué utilizar factores?

Un vector c(Femenino,  Masculino) (factor) presenta mayor información que un vector c(1, 2).

Un vector  character c("Femenino", "Masculino") no pueden ser incluido en modelos de regresión, un factor c(Femenino, Masculino) si. 

Un factor se crea mediante  la función: factor()

Si se dispone de un vector integer:
```{r}
vec <- c(1, 2, 2, 1, 2, 1, 2)
vec
```

La función factor asigna labels a los levels (o categorías)  de la variable. Los levels del vector vec son los valores 1, 2.

```{r}
# Creación de un factor
fac <- factor(vec, levels=c(1,2), labels = c("Femenino", "Masculino"))
fac
```

Si se dispone de un vector character:

```{r}
# Creación de un factor
vec <- c("Femenino","Masculino","Masculino","Femenino","Masculino", "Femenino","Masculino")
vec
```

La función factor asigna labels a los levels (o categorías) de la variable. En este caso los levels del vector vec son los valores "Femenino", "Masculino".

```{r}
# Creación de un factor
# por defecto labels = levels
fac <- factor(vec, levels= c("Femenino", "Masculino"), labels=c("FEM", "MASC"))
fac

```

Para obtener los atributos de un factor utilizamos attributes().

```{r}
vec <- c(1, 2, 2, 1, 2, 1, 2)
fac <- factor(vec, levels=c(1,2), labels = c("Femenino", "Masculino"))
# Atributos de un factor 
attributes(fac)
```

Para considerar el vector entero utilizamos unclass().

```{r}
# eliminación del atributo class 
unclass(fac)
```

Para realizar conteos por categoría, se utiliza la función table().

```{r}
fac <- factor(vec, levels=c(1,2), labels = c("Femenino", "Masculino"))
# frecuencias table(fac)
```

```{r}
# porcentaje 
prop.table(table(fac))
```


Data Frame
----------

Es una lista en la cual todos los elementos tienen la misma longitud. A diferencia de las matrices, pueden almacenar vectores atómicos de cualquier tipo. Presenta varios atributos adicionales class, rownames, names. Es la estructura de datos más utilizada para almacenar data tabulada.


Para  crear  un  data frame  se utiliza  la  función  data.frame(). Con  los siguientes vectores atómicos:

```{r}
dbl_vec <- c(1, 2, 3) 
chr_vec <- c("R", "S", "T") 
log_vec <- c(TRUE, FALSE, TRUE)
```

Creamos el data frame df:
```{r}
df <- data.frame(dbl_vec, chr_vec, log_vec)
df
```


Un data frame es una lista:
```{r}
typeof(df) # Tipo de un data frame
```


Su clase es data.frame:

```{r}
class(df)
```

Atributos de un data frame:

```{r}
attributes(df)
```

Nombres de las columnas de df:

```{r}
names(df)
```

Nombres de las filas de df:

```{r}
rownames(df)
```

Dimensión: Filas y columnas

```{r}
dim(df)
```

Número de filas y columnas
```{r}
nrow(df)
```

Elementos de un data frame:

Mediante df[i, j] se obtiene la componente i, j del data frame.

```{r}
nomb <- c("John", "Paul", "George", "Ringo")
nac <- c(1940, 1941, 1943, 1940)
instr <- c("guitar", "bass", "guitar", "drums")

df <- data.frame(nomb, nac, instr)
df[2, c(2,3)]
```

```{r}
print(df)
```

```{r}
df[2, 2] # componente 2, 2
```

```{r}
df[3, 1] # componente 3, 1
```


```{r}
df[c(1, 4), ] # filas 1, 4
```

Se pueden seleccionar ciertas filas mediante TRUE y FALSE.

```{r}
df[c(TRUE, TRUE, FALSE, TRUE), ] # equivalente a df[c(1, 2, 4), ]
```

Importante: Reciclado:
```{r}
df[c(TRUE, FALSE), ] # equivalente a df[c(1, 3), ]
```

Importante: Filtrado  o subsetting:

```{r}
df[ , 3]=="guitar" # columna 3 de df igual a "guitar"
```

```{r}
f_guitar <- df[ , 3]=="guitar"
```

Filas donde la columna 3 es igual a "guitar"

```{r}
df[f_guitar, ]
```

```{r}
df[ , c(1, 3)] # columnas 1, 3
```

Columna de nombre "nac" 
```{r}
df[ , "nac"] # equivalente a df[ , 2]
```

Columnas de nombres "nomb y nac"
```{r}
df[ , c("nomb", "nac")] # equivalente a df[ , c(1, 2)]
```

Se pueden seleccionar ciertas columnas mediante TRUE  y FALSE:

```{r}
df[ , c(TRUE, FALSE, TRUE)] # equivalente a df[ , c(1, 3)]
```

Importante: Reciclado

```{r}
df[ , c(TRUE, FALSE)] # equivalente a df[ , c(1, 3)]
```

R Data Frames
----------
R posee varios data frames en sus bases de datos internas, por ejemplo: mtcars

    data(mtcars)

Visualización:

    View(mtcars)

```{r}
# n primeras filas 
head(mtcars,n = 2)

```

```{r}
# n últimas filas 
tail(mtcars,n = 2)

```


Atributos del data frame:

```{r}
attributes(mtcars)
```


Nombres de las columnas:	
```{r}
names(mtcars)	
```
```{r}
colnames(mtcars)						
```

Nombres de las filas

```{r}
rownames(mtcars)
```

Dimensiones en un data  frame:

```{r}
# Dimensión 
dim(mtcars)
```

```{r}
# Número columnas 
ncol(mtcars)
```

```{r}
# Número filas 
nrow(mtcars)

```


Función structure
----------

La función str() (structure) presenta  una  descripción compacta  de la estructura de datos. Usar View() es costoso computacionalmente.

```{r}
str(mtcars)
```

Missing Values
----------

Los valores perdidos en R se denotan  por NA, NaN. NA Not Available. Dato perdido.

```{r}
x <- c(NA, 3.2, NA, 5, NA)
x
```

NaN Not a Number. Resultado  de una indeterminación:
```{r}
y <- c(-1, 0/0, 0.8, 5, Inf*0)
y
```

Inf representa infinito.

is.na(x) retorna TRUE para elementos NA de un vector atómico o lista.

```{r}
x <- c(0, 3.2, NA, 5, NA)
is.na(x)
```

is.nan(x)  retorna TRUE  para elementos NaN de un vector atómico.

```{r}
y <- c(-1, 0/0, 5, Inf*0)
is.nan(y)
```


Importación y Exportación de datos
----------

Lectura de  datos
----------

R puede acceder a información almacenada  en distintos  formatos:

Archivos de excel .xls, .xlsx, .csv;
Archivos de texto plano .txt;
Archivos de spss .sav;
Archivos de la web;
Archivos de bases de datos,  etc.

Directorio de  trabajo
----------
Working  directory  (wd). Es la dirección donde  se almacenan,  leen y escriben los archivos utilizados y generados mediante R. getwd() permite obtener el wd actual:

```{r}
getwd()
```

setwd() permite setear un nuevo wd, por ejemplo:

    setwd("C:/Documentos/R_users_group")

list.files() enlista los nombres de los archivos en el wd actual. El parámetro pattern se usa para enlistar  los nombres de los archivos que contienen un determinado  patrón.

    list.files(pattern = ".R")

file.exists() verifica si existe una carpeta con un determinado nombre en el wd.

```{r}
# Verifica si existe o no una carpeta con nombre "r_users"
file.exists("r_users")
```

dir.create() permite crear nuevas carpetas en el wd.

```{r}
# Crea una nueva carpeta con nombre "files" 
dir.create("files")
```

R sobreescribe una carpeta sobre otra, de ahí la importancia de utilizar  previamente  file.exists().

[Back to Top](#top)

### <a name="leer"></a>¿Cómo leer  archivos en  R?

Lectura de  archivos .txt
----------
Se requiere leer un archivo en formato txt:  archivo.txt. Se utiliza la función read.table()

    data_txt <- read.table(file = "archivo.txt",sep = "\t", dec = ",", header = TRUE)
    str(data_txt)

Parámetros:


file: nombre del archivo (incluida  extensión);
sep: caracter  utilizado para separar  columnas (variables);
dec: caracter  utilizado para decimales;
header: TRUE,  si la primera  fila contiene los nombres de las columnas.

str()  describe la estructura de datos.

Por defecto R coerciona las variables categóricas a factor. El parametro stringsAsFactors=FALSE evita esta coerción.

    data_txt <- read.table(file = "archivo.txt",sep = "\t", dec = ",", header = TRUE, stringsAsFactors = FALSE)

Lectura de  archivos .csv
----------
Se requiere leer un archivo en formato  csv: archivo.csv,  se utiliza  las función read.csv  que presenta por defecto los argumentos: sep = ",",  dec = ".",  , header = TRUE

    data_csv <- read.csv(file = "archivo.csv")

read.csv2():  Se debe especificar los argumentos:  sep, dec, header

    data_csv2 <- read.csv2(file = "archivo.csv",sep = ",", dec = ".", header = TRUE)


Lectura de  archivos .xls,  .xlsx
----------
Se requiere leer un archivo en formato xls o xlsx: archivo.xlsx. Se utiliza la función read_excel() del paquete  readxl

    install.packages("readxl", dependencies = TRUE)
    library(readxl)
    ls("package:readxl")
    
Lectura del archivo archivo.xlsx:

    data_xlsx <- read_excel("archivo.xlsx",sheet = "datos",col_names = TRUE, na="")
    read.table("clipboard",sep = "\t",header = FALSE)


Parámetros:                                                               

sheet: Nombre de la hoja que contiene la data  (recibe también  el número de hoja);
col_names: TRUE  si la primera  fila contiene los nombres de las columnas;
na: los caracter  que se coerciona a NA.

Lectura de  archivos .sav
----------
Se requiere leer archivos desde spss, es decir en formato .sav: archivo.sav. Se utiliza la función read.spss()  del paquete  foreign.

    install.packages("foreign", dependencies = TRUE)
    library(foreign)
    ls("package:foreign")
    data_sav <- read.spss(file="archivo.sav", use.value.labels = TRUE, to.data.frame = TRUE)

Parámetros:

file: nombre del archivo (incluida  extensión);
use.value.labels: TRUE,  si se consideran las etiquetas de las variables;
to.data.frame: TRUE, para coercionar el archivo leído a data frame.


[Back to Top](#top)

### <a name="funciones"></a>Funciones


Introducción
----------

Una función es un conjunto  de instrucciones,  que a partir  de uno o más datos  de entrada, permiten generar y retornar un detrminado resultado.


¿Porqué construir funciones?
----------

Practicidad: Permiten  ejecutar  un conjunto  de instrucciones  en una sola línea de código. Ejemplo: La función  sort , las instrucciones necesarias para ordenar  un vector.

```{r}
x <- c(3, 1, 6, 2)
x
```

```{r}
sort (x)
```

Generalización: Permiten  diseñar  códigos para  casos determinados  y ajustarlos  a casos generales.

Ejemplo: Hallar la media de 3 y 4

```{r}
(3 + 4) / 2
```

Para hallar el promedio de varios pares de números, creamos la función  promedio.

```{r}
promedio <- function(a, b) {
prom <- (a + b) / 2 
return (prom)
}
```


Estructura de  una función
----------

El comando  function() tiene como tarea  crear funciones a partir  de ciertos argumentos  que son proporcionados  por el usuario.

No existe un límite en la cantidad de argumentos que una función puede recibir.

```{r}
promedio_pond <- function(a, b, peso1, peso2) {
prom <- peso1*a + peso2*b 
return (prom)
}
```

Ejemplos:	
```{r}
promedio_pond(a=	1, b	= 5, peso1 = 0.8, peso2 =	0.2)
```

Argumentos  por default
----------

Existen ocasiones que no se requieren ingresar ciertos argumentos para que la función pueda ejecutarse.

Estos valores por default deben colocarse en la función:

```{r}
promedio_pond <- function(a, b, peso1 = 0.5, peso2 = 0.5) {
prom <- peso1*a + peso2*b 
return (prom)
}
promedio_pond(a = 1, b = 5)

```

Lexical Scoping
----------

Variable libre: Una variable en una función se dice libre si no ha sido definida o no es un argumento.

El lexical Scoping permite entender cómo R asocia un valor a una variable libre (crear un objeto).

```{r}
f <- function(x, y) {
return(x^2 + y / z)
}
```

Argumentos: x, y. Variables libres: z.

```{r}
f(x = 3, y = 6)
```

Considere la siguiente función:

```{r}
z <- 10
f <- function(x) {
z <- 2
z^2 + g(x)
}
g <- function(x) {
x*z
}
```

Cuál es el valor de f(x = 3) ?

```{r}
f(x = 3)
```

[Back to Top](#top)

### <a name="estructuras"></a>Estructuras de Control

----------

Son herramientas que permiten  manejar  de una forma mucho más estructurada el flujo de ejecución de un código. Las estructuras de control se clasifican en:

Condicionales: if, else (e ifelse). 
Loops o bucles: for, while.

Sentencia if
----------

La sentencia if realiza una tarea  para un determinado  caso.

CONDICION: Vector lógico 1d  TRUE/FALSE . Si condicion es TRUE se ejecuta la tarea. Forma  de declarar la sentencia if:

```{r}
x <- 2
if(x > 0) {
x <- x + 1
}
x 
```

Sentencia else
----------
La sentencia else trabaja conjuntamente con la sentencia if

<center>
![](https://raw.githubusercontent.com/Rgrupoec/Rgrupoec.github.io/master/img/publicaciones/2017-07-23-if.jpg)</center>
<br>

Si la condición es TRUE se ejecuta la Tarea 1, caso contrario  se ejecuta la Tarea  2.

Sentencia if else
----------

Forma  de declarar la sentencia  if else :

```{r}
x <- -1
if (x >= 0) {
print("El número es positivo")
} else {
print("El número es negativo")
}
```

Sentencia for
----------

La sentencia for permite  repetir  una acción un número determinado  de veces.

Forma de declarar la sentencia for:

Ejemplo: Suma de filas/columnas: m: matriz de 4x3 de Poisson

```{r}
m <- matrix(data = rpois(n = 12, lambda = 8), nrow = 4, ncol = 3)
m
```

```{r}
col_sumas <- numeric(ncol(m))
for (i in 1:4){
col_sumas[i] <- sum(m[i,])
}
col_sumas                                                                 
```


Funciones loop tipo ”apply”
----------

apply
----------

Apply se utiliza para evaluar una función (a menudo anónima)  sobre los márgenes de una matriz. Se utiliza  con mayor frecuencia para  aplicar  una función a las filas o columnas de una matriz.  Se puede usar con matrices generales, p. Tomando  el promedio de una matriz de matrices  no es realmente  más rápido que escribir un bucle, pero funciona en una línea!

```{r}
str(apply)
```

X es una matriz

MARGIN es un vector  entero  que indica qué márgenes deben ser retenidos". FUN es una función a ser aplicada para que otros argumentos  sean pasados a FUN

```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean)
```

col/row Sumas y Medias
----------

Para las sumas y los medias de las dimensiones de la matriz,  tenemos algunos atajos:

```{r}
rowSums = apply(x,  1, sum)
rowMeans = apply(x,  1, mean)
colSums = apply(x,  2, sum)
colMeans = apply(x,  2, mean)
```

Las funciones de acceso directo son mucho más rápidas, pero no te darás  cuenta a menos que estés usando una matriz grande.

Otras Formas de Aplicar

Quantiles de las filas de una matriz.

```{r}
x <- matrix(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75))
```

Matriz media en una matriz
----------

```{r}
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
```

tapply
----------

tapply se utiliza para aplicar una función sobre subconjuntos  de un vector.

```{r}
str(tapply)
```

X es un vector
INDICE es un factor o una lista de factores (o bien son coaccionados a factores) FUN es una función a ser aplicada  contiene otros argumentos  para ser evaluados FUN simplificar, ¿debemos simplificar el resultado?

Tomar  grupos significa:	

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f	
```

Tomar medias de grupos sin simplificación.												

```{r}
tapply(x, f, mean, simplify = FALSE)
```

Encuentra rangos de grupo.

```{r}
tapply(x, f, range)
```

lapply y sapply
----------

La escritura de while es útil cuando  se programa  pero no es especialmente fácil cuando  se trabaja interactivamente en la línea de comandos. Hay algunas funciones que implementan bucles para facilitar la vida.

Lapply: Bucle sobre una lista y evaluar una función en cada elemento
Sapply: Lo mismo que lapply pero intenta simplificar el resultado
Apply: Aplicar una función sobre los márgenes de una matriz
Tapply:  Aplicar una función sobre subconjuntos de un vector
Mapply: Versión multivariable de lapply

También es útil una división de función auxiliar, particularmente en conjunción con lapply.

lapply
----------

Lapply toma tres argumentos:
(1) una lista X; 
(2) una función (o el nombre de una función) FUN; 
(3) otros argumentos a través de su argumento.  Si X no es una lista, será coaccionado a una lista usando as.list.

```{r}
lapply
```

El bucle real se realiza internamente en código C.

Lapply siempre devuelve una lista, independientemente de la clase de la entrada.

```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
```

```{r}
x <- 1:4 
lapply(x, runif)
```

```{r}
x <- 1:4
lapply(x, runif, min = 0, max = 10)
```

Lapply permite hacer un uso intensivo de funciones anónimas.

```{r}
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x
```

Una función anónima para extraer la primera columna de cada matriz.

```{r}
lapply(x, function(elt) elt[,1])
```

Sapply
----------
Sapply tratará de simplificar el resultado  de lapply si es posible.

Si el resultado  es una lista donde cada elemento es la longitud 1, entonces se devuelve un vector

Si el resultado  es una  lista  donde  cada  elemento  es un vector  de la misma longitud (>1), se devuelve una matriz.

Y no puede calcular, se devuelve una lista


```{r}
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
```

```{r}
sapply(x, mean)
```

mapply
----------
Mapply es una aplicación multivariable de tipos que aplica una función en paralelo sobre un conjunto  de argumentos.

```{r}
str(mapply)
```

FUN es una función para aplicar
... contiene argumentos  para aplicar
MoreArgs es una lista de otros argumentos para FUN.
SIMPLIFY indica si el resultado debe ser simplificado

El siguiente listado es tedioso digitar: list(rep(1,  4), rep(2, 3), rep(3, 2), rep(4, 1)) Por lo cual se puede hacer:

```{r}
mapply(rep, 1:4, 4:1)
```

Vectorizando una Función
----------

```{r}
noise <- function(n, mean, sd) {
rnorm(n, mean, sd)
}
```


Vectorización instantánea
----------
```{r}
mapply(noise, 1:5, 1:5, 2)

```

Lo cual es lo mismo que:

```{r}
list(noise(1, 1, 2), noise(2, 2, 2),    noise(3, 3, 2), noise(4, 4, 2), noise(5, 5, 2))
```

split
----------

split toma un vector u otros objetos y lo divide en grupos determinados  por un factor o una lista de factores.

```{r}
str(split)
```

X es un vector (o lista) o un marco de datos
F es un factor (o coaccionado a uno) o una lista de factores
Drop indica si los niveles de factores vacíos deben ser eliminados

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x, f)
```

Una función común se divide seguido de un lapply.

```{r}
lapply(split(x, f), mean)
```

División de  un  data frame 

```{r}
library(datasets)
head(airquality)
```

```{r}
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))

```

```{r}
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
```

División en más de un nivel

```{r}
x <- rnorm(10) 
f1 <- gl(2, 5) 
f2 <- gl(5, 2)
f1
```

Interacciones pueden crear niveles vacios:

```{r}
str(split(x, list(f1, f2)))
```

Se pueden eliminar niveles vacíos:

```{r}
str(split(x, list(f1, f2), drop = TRUE))
```

[Back to Top](#top)

